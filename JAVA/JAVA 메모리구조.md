## JAVA 메모리구조

**JVM(Java Virtual Machine)**은 Java byte code를 실행할 수 있는 주체이다.

운영체제 위에서 동작하는 프로세스로 자바 코드를 컴파일해서 얻을 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할을 한다.

중요한 것은 **운영체에에 의존적이지 않고 독립적으로 java 프로그램이 실행된다.**

<br>

<img src="https://user-images.githubusercontent.com/32161395/73610168-ea75c400-4617-11ea-9a6a-bb5e15053586.jpg" width="90%"></img>

<br>

#### java 컴파일러

\- .java 소스를 **Java Compiler(자바 컴파일러)**가 컴파일하면 Byte code(.class 파일)로 변환된다.

#### Class Loader

\- 변환된 Byte code(.class) 파일은 **Class Loader**가 **Runtime Data Area** ( JVM이 운영체제로부터 할당받은 메모리영역 ) 내로 로드(load)한다. (자바 애플리케이션이 실행 중일 때 이런 작업이 수행된다.)

#### Execution Engine

\- Class Loader에 의해 메모리에 적재된 클래스(바이트 코드)들은 기계어로 변경해 명령어 단위로 실행하는 역할을 한다.

\- 명령어를 하나하나 실행하는 인터프리터(Interpreter)방식이 있고 JIT(Just-In-Time) 컴파일러를 이용하는 방식이 있다.

\- JIT 컴파일러는 적절한 시간에 전체 바이트 코드를 네이티브 코드로 변경해서 Execution Engine이 네이티브로 컴파일된 코드를 실행하는 것으로 성능을 높이는 방식이다.

#### Garbage Collector

\- Garbage Collector(GC)는 Heap 메모리 영역에 생성(적재)된 객체들 중에 참조되지 않는 객체들을 탐색 후 제거하는 역할을 한다.

\- GC가 역할을 하는 시간은 정확히 언제인지를 알 수 없다. (참조가 없어지자마자 해제되는 것을 보장하지 않음)

\- 또 다른 특징은 GC가 수행되는 동안 GC를 수행하는 쓰레드가 아닌 다른 모든 쓰레드가 일시정지된다.

\- 특히 Full GC가 일어나서 수 초간 모든 쓰레드가 정지한다면 장애로 이어지는 치명적인 문제가 생길 수 있는 것이다. (GC와 관련된 내용은 아래 Heap영역 메모리를 설명할 때 더 자세히 알아본다.)

#### Runtime Data Areas

\- 런타임 데이터 영역은 JVM의 메모리 영역으로 Java 어플리케이션이 실행하면서 할당받은(실행할 때 사용되는) 메모리영역이다.

\- 이 영역은 크게 Method 영역, Heap 영역, Stack 영역, PC Register, Native Method Stack 으로 나눌 수 있다.

<img src="https://user-images.githubusercontent.com/32161395/73610170-eea1e180-4617-11ea-8724-5b7ecffc3162.png" width="90%"></img>



**이 중 세가지 중요한 영역을 간단하게 정리하면**

#### 메소드영역

\- 프로그램 실행 중 어던 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이 때, 그 클래스 변수(class variable)도 이 영역에 함께 생성된다.

#### 힙(Heap) 영역

\- 인스턴스 변수들이 생성되는 공간이며, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.

#### (Call) Stack 영역

\- call stack(호출 스택) 영역은 메소드의 작업에 필요한 메모리 공간을 제공한다. 메소드가 호출되면, 호출스택에 호출된 메소드를 위한 메모리가 할당되며, 이 메모리는 메소드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메소드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.

\- 메소드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.

\- 메소드가 수행을 마치고 나면 사용했던 메모리를 반환하고 스택에서 제거된다.

\- 호출스택의 제일 위에 있는 메소드가 현재 실행 중인 메소드이다.(이건 물리적으로 그런건 아니고 직관적으로 떠오르기위해 약속한 것이다.)

\- 아래에 있는 메소드가 바로 위의 메소드를 호출한 메소드이다.

<br>

### 질문

가비지 컬렉터는 어떤 객체들을 어떤 순서데로 제거 할까?

Garbage Collection 과정은 Mark and Sweep 이라고도 한다. 

JVM의 Garbage Collector 가 스택(메소드 작업에 필요한 공간을 제공한다) 의 모든 변수를 스캔하면서 각각 어떤 오브젝트(Heap영역에 있다)를 레퍼런스 하고 있는지 찾는과정이 Mark 다. Reachable 오브젝트가 레퍼런스하고 있는 오브젝트 또한 marking 한다. 

첫번째 단계인 marking 작업을 위해 모든 스레드는 중단되는데 이를 stop the world 라고 부르기도 한다. (System.gc() 를 생각없이 호출하면 안되는 이유이기도 하다)

그리고 나서 mark 되어있지 않은 모든 오브젝트들을 힙에서 제거하는 과정이 Sweep 이다.

Garbage Collection 이라고 하면 garbage 들을 수집할 것 같지만 실제로는 garbage 를 수집하여 제거하는 것이 아니라, garbage 가 아닌 것을 따로 mark 하고 그 외의 것은 모두 지우는 것이다. 만약 힙에 garbage 만 가득하다면 제거 과정은 즉각적으로 이루어진다.



아니 그런데.. 

스택에는 메소드관련 변수가 있는데 이 변수들이 참조하는 객체(힙영역에 있다 -> 그럼 인스턴스인데..)들

을 참조하는데 참조를 안하고 있는 메소드 관련 변수도 있나?



ex) 

Animal cat;	// 객체

cat = new Animal();	// cat은 Animal 클래스의 인스턴이 이다.