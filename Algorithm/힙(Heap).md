# 힙(Heap)

### 1. Heap 이란?

- 개념

  - Heap이란 `완전 이진트리의 일종`으로 부모 노드와 자식 노드간에 항상 대소관계가 성립하는 자료구조이다.
  - 아래 그림처럼 부모 노드가 자식보다 항상 크며 이러한 구조를 최대힙(Max Heap)이라고 하고, 그 반대를 최소힙(Min Heap)이라고 한다.
  - 이 때 부모와 자식 노드의 대소관계만 중요하며 형제 노드들간에 관계는 없다.
  - 이렇게 부모와 자식간에 대소관계를 띄기 때문에 최상단 부모인 루트에는 항상 가장 크거나 작은 값이 오며 이를 이용해서 `우선 순위 큐(Priority Queue)`의 구현이 가능하다. (Heap = 우선 순위 큐가 아니라 Heap을 이용해서 우선 순위 큐의 구현이 가능한 것이다.)

  \- 참고로 `포화 이진 트리`는 모든 잎의 레벨이 동일한 이진 트리이며, 잎이 아닌 내부 노드들은 모두 2개의 자식을 가지는 트리

  \- `완전 이진 트리`는 포화 이진 트리의 leaf들을 오른쪽에서부터 제거하여 얻어진 트리

<br>

![Priority_Queue](https://user-images.githubusercontent.com/32161395/75873669-a4e52a80-5e53-11ea-8b4b-0d9c6fec1689.png)

<br>

- 구현(배열 예제)
  - 완전 이진트리는 배열 또는 연결리스트를 사용한다.(여기서는 배열 구현)
  - 구현을 쉽게 하기 위해 배열을 사용할 때 인덱스는 1부터 사용한다. ('0' 사용x)
  - 특정 노드의 배열 인덱스가 `current`라고 한다면 `부모 노드`는 `current/2`를 통해 찾아갈 수 있고 `자식 노드`는 `current*2`(좌측 자식 노드) 또는 `current*2 +1`(우측 자식 노드)를 통해서 찾아갈 수 있다. 

<br>

### 2. Heap의 일반적인 문제 해결방법

`binaray heap`자료구조를 활요할 Sorting 방법에는 두 가지 방법이 존재한다.  

1. 하나는 정렬의 대상인 데이터들을 힙에 넣었다가 꺼내는 원리로 Sorting을 하게 되는 방법이다.
2. 나머지 하나는 기존의  배열을 `heapify`(heap 으로 만들어주는 과정)을 거쳐 꺼내는 원리로 정렬하는 방법이다. 

 `heap`에 데이터를 저장하는 시간 복잡도는 `O(log n)`이고, 삭제 시간 복잡도 또한 `O(log n)`이 된다. 때문에 힙 자료구조를 사용하여 Sorting 을 하는데 time complexity 는 `O(log n)`이 된다. 이 정렬을 하려는 대상이 n 개라면 time complexity 는 `O(nlogn)`이 된다.

